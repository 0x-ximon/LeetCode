#+title: Queue and Stack
#+author: Simon Samuel
#+date: <2025-03-27 Thu>

* Queue: First-in-First-out Data Structure
In a FIFO data structure, the *first element added to the queue will be processed first.* The insert operation is also called ~enqueue~ and the new element is always *added at the end of the queue*. The delete operation is also called ~dequeue~ and you're only allowed to *remove the first element*.

To implement a ~Queue~, we may use a dynammic array and have an head pointing to the writing index as in this:

#+begin_src cpp
  #include <vector>
  using namespace std;

  class Queue {
     private:
      std::vector<int> data;
      int head;

     public:
      Queue() { head = 0; };

      bool enqueue(int val) {
          data.push_back(val);
          return true;
      }

      bool dequeue() {
          if (head >= data.size()) {
              return false;
          };

          head++;
          return true;
      }

      int read() {
          if (head >= data.size()) {
              return 0;
          }

          return data[head];
      }
  };
#+end_src 

This becomes very inefficient as we have spaces in front that actually never get filled after dequeuing. We can instead try using a circular queue.

** Circular Queue
A more effective solution would be to use a static array and then have two pointers pointing to the head and tail of the queue so you know where to insert to and delete from during enqueing and dequeing. This is the most optimal as all operations are constant time.

#+begin_src cpp
  #include <vector>
  using namespace std;

  class CircularQueue {
     private:
      vector<int> data;
      int length;

      int head;
      int tail;

     public:
      CircularQueue(int k) {
          head = 0;
          tail = -1;

          length = 0;
          data.resize(k);
      }

      // Algorithm Analysis
      //      Time Complexity:     Ο(1) Ω(1) Θ(1)
      //      Space Complexity:    Ο(1) Ω(1) Θ(1)
      bool enQueue(int value) {
          if (isFull())
              return false;

          if (tail == data.size() - 1)
              tail = 0;
          else
              tail++;

          data[tail] = value;

          length++;
          return true;
      }

      // Algorithm Analysis
      //      Time Complexity:     Ο(1) Ω(1) Θ(1)
      //      Space Complexity:    Ο(1) Ω(1) Θ(1)
      bool deQueue() {
          if (isEmpty())
              return false;

          if (head == data.size() - 1)
              head = 0;
          else
              head++;

          length--;
          return true;
      }

      // Algorithm Analysis
      //      Time Complexity:     Ο(1) Ω(1) Θ(1)
      //      Space Complexity:    Ο(1) Ω(1) Θ(1)
      int Front() {
          if (isEmpty())
              return -1;

          return data[head];
      }

      // Algorithm Analysis
      //      Time Complexity:     Ο(1) Ω(1) Θ(1)
      //      Space Complexity:    Ο(1) Ω(1) Θ(1)
      int Rear() {
          if (isEmpty())
              return -1;

          return data[tail];
      }

      // Algorithm Analysis
      //      Time Complexity:     Ο(1) Ω(1) Θ(1)
      //      Space Complexity:    Ο(1) Ω(1) Θ(1)
      bool isFull() { return length == data.size(); }

      // Algorithm Analysis
      //      Time Complexity:     Ο(1) Ω(1) Θ(1)
      //      Space Complexity:    Ο(1) Ω(1) Θ(1)
      bool isEmpty() { return length == 0; }
  };
#+end_src
